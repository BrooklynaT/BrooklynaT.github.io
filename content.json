[{"title":"Promise模拟请求中断","date":"2018-08-26T14:05:55.000Z","path":"2018/08/26/Promise模拟请求中断/","text":"Promise 模拟请求中断#语言/JavaScript 背景我司 app 一级入口的个人中心页面采用 Hybrid 开发方式，每次进入页面都会请求用户最新数据，当快速在「个人中心」页与其他页面切换时，可能会发生重复的网络请求造成列表数据混乱。具体表现为当第一个网络请求发出，未返回时，切到其他页面，再快速切回来，就会发第二个网络请求。后果是分页的第一页数据重复。 解决方案 后端在每页返回的数据中标明当前数据是第几页，前端在使用前判断如果是第一页数据就直接使用当前数据替换原有列表数据。 前端主动取消重复的网络请求。 实践 后端生病了，无法及时响应需求😂。 我们的 Hybrid 方案是公司前端与客户端开发 SDK，作为业务前端，发现现有的 fetch 方法其实是客户端提供原生的网络请求方法，经过 JS-SDK 封装后暴露出来的方法，目前 SDK 不支持请求中断，所以最后方案是我这边使用 Promise hack 一下。 code The Promise.race(iterable) method returns a promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.Promise.race 方法将多个 Promise 对象组成的迭代器包装成一个 Promise 对象，当迭代器中的某个 Promise resolve 或者 reject 时，该对象就会 resolve 或者 reject。race 就是竞赛的意思，谁速度快（率先返resolve 或者 reject）谁就赢，整个迭代器其他的 Promise 的状态我们就不关心了。 基于此，封装一个包装 fetch 的方法如下123456789101112export function fetchWithAbort(fetchPromise) &#123; let abort = null const abortPromise = new Promise((resolve, reject) =&gt; &#123; abort = () =&gt; &#123; reject('abort') console.log('=== fetchWithAbort abort ===') &#125; &#125;) let promiseWithAbort = Promise.race([fetchPromise, abortPromise]) promiseWithAbort.abort = abort return promiseWithAbort&#125; 使用(示例代码是在 .vue 中使用)12345678910111213if (this.productionFetchPromise &amp;&amp; this.productionFetchPromise.abort) &#123; this.productionFetchPromise.abort()&#125;this.productionFetchPromise = fetchWithAbort(getProductionHttp(this.page, PAGE_SIZE))this.productionFetchPromise.then(res =&gt; &#123; console.log('=== fetch success ==='. res)&#125;).catch(err =&gt; &#123; if (err === 'abort') &#123; console.log('=== fetch abort ===', err) return &#125; console.log('=== fetch err ===', err)&#125;) 在每次发起网络请求前，先 abort 掉之前的 fetch，其实并没有真的中断请求，只是让之前的请求 Promise reject 掉，使我们不必关心之前的网络请求是成功还是失败。 联想当 abort 写出来了，其实自定义超时的方法也就出来了，甚至更加简单12345678function fetchWithTimeout(fetchPromise) &#123; const timePromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('timeout') &#125;, 5000) &#125;) return new Promise.race([fetchPromise, timePromise])&#125; 问题使用这种方案虽然解决了业务需求，但是我这边一直都是使用 async await 处理网络事件，这种方案让这边的代码风格变得不一致，虽然工作量不大，但是修改这的网络请求相关代码还是费了点时间，之后可以考虑下可否保持原先的 async await 代码，无痛切换到 fetchWithAbort。 以上。 参考文献 Promise.race() - JavaScript | MDN Fetch进阶指南 | louis blog","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"vue聊天室登录过程","date":"2017-07-30T14:22:13.000Z","path":"2017/07/30/vue聊天室登录过程/","text":"使用 vue 的 SPA 的登录逻辑这两天将之前分开写的几个聊天室的页面给串起来了，这里顺便记录下登录的逻辑。其实说白了就是用户状态的判断，根据结果跳转不同的页面。再往下分析的话，就三个点。 用户是否是已登录的状态 在何时去判断用户状态 未登录用户跳转登录页面（vue-router） 判断用户登录状态这里我使用的是由纯前端判断用户的登录状态，在用户登录时，后端返回token，前端存储到本地，依据本地 token 是否存在判断用户是否登录。123456789101112131415161718// src/main.jsnew Vue(&#123; methods: &#123; checkLogin: function () &#123; // 检测本地是否存在 id cookie if (this.getCookie('token')) &#123; // 用户已登录时跳转到内容页 this.$router.push('/'); &#125; else &#123; // 未登录时跳转到登录页 this.$router.push('/login'); &#125; &#125;, getCookie: function (name) &#123; return window.localStorage.getItem(name); &#125; &#125;&#125;); 何时判断用户的状态 用户打开页面时 路由发生变化时跳转到某些需要权限的页面时判断用户是否有权访问该页面也可以使用此方法。1234567891011// src/main.jsnew Vue(&#123; created () &#123; // 打开页面的时候检测登录状态 this.checkLogin(); &#125;, watch: &#123; // 监听路由变化 '$router': 'checkLogin' &#125;&#125;); 这个周末比较匆忙，有时间的话补一下结合 vuex 登录的具体操作吧。","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"在vue及egg中使用socket.io","date":"2017-07-23T08:20:32.000Z","path":"2017/07/23/在vue及egg中使用socket-io/","text":"vue-socket.io 及 egg-socket.io 的简单使用这是一篇究极文不对题的博客，因为我要介绍的并不是 socket.io 在 vue 以及 egg 的使用。既然你还想知道然后。。。。。。。我就告诉你我要介绍的是 vue-socket.io 以及 egg-socket.io。因为最近手又痒了想写个聊天室熟悉下 vue 以及 nodeJs。真实原因是，我身边最后一个单身的程序员竟然也找到了女朋友噩耗传来一番思考我想通了故事讲完了。总结：聊天室项目，前端 vue，后端 egg，\b使用 vue-socket.io，egg-socket.io egg-socket.io 的使用官方文档看这里 egg-socket.io接下来的内容其实与文档里差不多，介意的童鞋略过就好，目前只是简单的引入，下周往后会写复杂些的逻辑，在后面的文章会介绍。贴下目录结构 下载安装 1$ npm install --save egg-socket.io 开启插件以及插件配置开启插件 12345// app/config/plugin.jsexports.io = &#123; enable: true, package: 'egg-socket.io'&#125;; 插件配置12345678910// app/config/config.default.js// 这里的 auth 以及 filter 是待会会编写的两个中间件，用于不用依据自己的情况选择即可exports.io = &#123; namespace: &#123; '/': &#123; connectionMiddleware: [ 'auth' ], packetMiddleware: [ 'filter' ], &#125; &#125;&#125;; 编写中间件 12345678910111213141516171819// app/io/middlewware/auth.js// 这个中间件的作用是提示用户连接与断开的，连接成功的消息发送到客户端，断开连接的消息在服务端打印module.exports = app =&gt; &#123; return function* (next) &#123; this.socket.emit('res', 'connected!'); yield* next; console.log('disconnection!'); &#125;;&#125;;// app/io/middleware/filter.js// 这个中间件的作用是将接收到的数据再发送给客户端module.exports = app =&gt; &#123; return function* (next) &#123; this.socket.emit('res', 'packet received!'); console.log('packet:', this.packet); yield* next; &#125;;&#125;; 编写控制器 12345678910// app/io/controller/chat.js// 将收到的消息发送给客户端module.exports = app =&gt; &#123; return function* () &#123; const self = this; const message = this.args[0]; console.log('chat 控制器打印', message); this.socket.emit('res', `Hi! I've got your message: $&#123;message&#125;`); &#125;;&#125;; 编写路由 12345// app/router.js// 这里表示对于监听到的 chat 事件，将由 app/io/controller/chat.js 处理module.exports = app =&gt; &#123; app.io.of('/').route('chat', app.io.controllers.chat);&#125;; tip：1234567// controller 中// 发送给自己this.socket.emit('eventName', 'value');// 发送给除了自己外的所有人this.socket.broadcast.emit('eventName', 'value');// 发送给所有人，包括自己this.server.sockets.emit('eventName', 'value'); 前两种书写方式都与 socket.io 一致，最后一种 socket.io 使用的是 io.sockets.emit，但是无奈小白怎么都找不到这个 io，但是这怎么可能阻止机制的我呢，直接开 debug 模式，将当前环境下的对象打印出来，找到了一个个 server，里面有 sockets 对象，试了下，竟然成功了，暂时没时间研究为什么，等项目写的差不多了，对 egg 了解多点再回头填这个坑吧，先立个 flag。写到这里 npm run dev 没报错的话应该是问题不大，但是要测试是否成功，我们需要在前端也用上 socket。 vue-socket.io 的使用这里是没有加上 vuex 的食用方法，后续会补上。文档在这里vue-socket.io。因为涉及到的文件比较少，这里就不贴目录结构了，这边的项目是 vue-cli 初始化的，所以看客老爷脑补下就好。 下载 1$ npm install --save vue-socket.io 连接服务器，以及接收服务端消息 12345678910111213141516171819// src/main.jsimport VueSocketio from 'vue-socket.io';Vue.use(VueSocketio, 'http://127.0.0.1:7001/');new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;, sockets: &#123; connect: function () &#123; console.log('socket connected'); &#125;, res: function (val) &#123; console.log('接收到服务端消息', val); &#125; &#125;&#125;); Vue.use()里面的 url 是你服务器地址。connect 是 socket.io 默认的事件，看这名字就知道是干啥的了，另外一个 res 是自定义的监听事件，表示监听服务端发送的名为 res 的事件。 向服务端发送消息12345678&lt;script&gt; // ... methods: &#123; sendMessageToServer: function() &#123; this.$socket.emit('chat', '111111111111'); &#125; &#125;&lt;/script&gt; 这里我们使用的事件名为 chat，所以服务端会将这条消息交给 chat.js（就是上面服务器端项目里面的文件啦） 这个控制器处理。 效果如图开始报的错误是因为后端服务器没打开，连接失败，至于那个 undefined 也可以忽略，这是安装的一个 chrome 插件报的，好像是收趣搞得鬼。左边窗口是服务端打印的内容，右边自然是客户端的打印啦。 以上。 参考链接 egg-socket.io vue-socket.io","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"faramework","slug":"faramework","permalink":"http://yoursite.com/tags/faramework/"},{"name":"egg","slug":"egg","permalink":"http://yoursite.com/tags/egg/"}]},{"title":"vue项目个人配置","date":"2017-07-16T06:39:36.000Z","path":"2017/07/16/vue项目个人配置/","text":"Vue 自用配置一般项目都会使用 vue-cli 初始化项目，大部分使用的都是默认配置，但是也有一些配置并不符合个人的使用习惯，所以存在定制化的需求，当然如果有团队规范的话，那就直接使用团队规范，没什么好说的。最近开了一个聊天室的小项目，发现有些默认配置存在一些不顺手的情况，就自己折腾了一下，在这里做个记录。 ESlintvue 默认使用的是 standard 模式，这里是 standard 模式的相关文档。vue-cli init项目时如果选择了 eslint，会在根目录生成 .eslintignore 和 .eslintrc.js文件，.eslintignore 文件类似于 .gitignore，描述哪些文件不必使用 eslint 规范，.eslintrc.js 文件中就是 eslint 的具体规则配置文件。大部分还是按照默认配置来，只是修改了以下选项：123456789'rules': &#123; // 0-off, 1-warn, 2-error // 关闭缩进使用两个空格 'indent': 'off', // 关闭句尾不允许加分号 'semi': 'off', // 将定义未使用变量的提示改为警告 'no-unused-vars': 'warn'&#125; 属性值 0 与 off 代表不启用该规则，1 与 warn 代表违反该规则时显示警告，2 与 error 代表违反该规则时显示错误提示。关于是否使用分号，现在的讨论很多，个人觉得这是个人编码习惯的事情，像我从写第一行 js 开始就使用分号，习惯了，既然他没有错误，也不算编码恶习，那我就接着用，不必纠结。关于缩进，那就更是如此了，我习惯用四个空格那就四个喽。 使用 scss 安装以下三个依赖： node-sass sass-loader style-loader 在 build 文件夹下的 webpack.base.conf.js 中添加如下规则： 12345678module: &#123; rules: [ &#123; test: /\\.scss$/, loaders: ['style', 'css', 'sass'] &#125; ]&#125; 在 style 中添加 lang=&quot;scss&quot; 123&lt;style lang=\"scss\"&gt;@import './styles/index.scss';&lt;/style&gt; 这里我们使用的是 scss，如果填写 sass，需要注意 scss 与 sass 的语法差异，例如 sass 不允许花括号等等。","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"http1","date":"2017-07-09T07:24:30.000Z","path":"2017/07/09/http1/","text":"Http 基础知识（一）Web 使用一种名为 HTTP (HyperText Transfer Protocol，超文本传输协议)的协议作为规范，完成从客户端到服务器端等一系列运作流程。 TCP/IP 协议族HTTP 协议属于 TCP/IP 内部的一个子集。把与互联网相关联的协议集合起来总称为 TCP/IP。也有说 法认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为 ，TCP/IP 是在 IP 协议的通信过程中，使用到的协议族的统称。TCP/IP 协议族按层次分别分为以下 4 层: 应用层 传输层 网络层 数据链路层 应用层应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP(File Transfer Protocol，文件传输协议)和 DNS(Domain Name System，域名系统)服务就是其中两类。HTTP 协议也处于该层。 传输层传输层为应用层提供处于网络连接中的两台计算机之间的数据传输服务。在传输层有两个性质不同的协议:TCP(Transmission Control Pr otocol，传输控制协议)和 UDP(User Data Protocol，用户数据报协议)。 网络层网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径(所谓的传输路线)到达对方计算机，并把数据包传送给对方。 数据链路层用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备 驱动、NIC(Network Interface Card，网络适配器，即网卡)， 及光纤等物理可见部分(还包括连接器等一切传输媒介)。硬件上的范畴均在链路层的作用范围之内。一个例子： 首先作为发送端的客户端在应用层( HTTP 协议)发出一个想看某个 Web 页面的 HTTP 请求。 接着，为了传输方便，在传输层(TCP 协议)把从应用层处收到 的数据(HTTP 请求报文)进行分割，并在各个报文上打上标记 序号及端口号后转发给网络层。 在网络层(IP 协议)，增加作为通信目的地的 MAC 地址后转发 给链路层。这样一来，发往网络的通信请求就准备齐全了。 接收端的服务器在链路层接收到数据，按序往上层发送，一直到 应用层。当传输到应用层，才能算真正接收到由客户端发送过来 的 HTTP 请求。发送端在层与层之间传输数据时，每经过一层必定会打上一个该层所属的首部信息，反之，接收端在层与层传输数据时，每经过一层会把对应的首部消去。这种把数据信息包装起来的方法称为封装。 与 HTTP 关系密切的协议：IP、TCP、DNS负责传输的 IP 协议按层次分，IP(Internet Protocol)网际协议位于网络层。IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到 对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址 和 MAC 地址(Media Access Control Address)。IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的 固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换， 但 MAC 地址基本上不会更改。 使用 ARP 协议凭借 MAC 地址进行通信IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域 网(LAN)内的情况是很少的，通常是经过多台计算机和网络设 备中转才能连接到对方。而在进行中转时，会利用下一站中转设 备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议 (Address Resolution Protocol)。ARP 是一种用以解析地址的 协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。 确保可靠的 TCP 协议TCP 位于传输层，提供可靠的字节流服务所谓的字节流服务(Byte Stream Service)是指，为了方便传输 ，将大块数据分割成以报文段(segment)为单位的数据包进行 管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方 。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割， 而且 TCP 协议能够确认数据最终是否送达到对方。 TCP 建立连接三次握手 首先Client端发送连接请求报文 Server段接受连接后回复ACK报文，并为这次连接分配资源 Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。 TCP 断开连接四次挥手 Client端发起中断连接请求，也就是发送FIN报文。(我Client端没有数据要发给你了) Server 端发送 ACK。（告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息） 当Server端确定数据已发送完成，则向Client端发送FIN报文。（告诉Client端，好了，我这边数据发完了，准备好关闭连接了） Client端收到FIN报文后，向 Server 发送ACK（Server端收到ACK后，就知道可以断开连接了），如果Server端没有收到ACK则可以重传，如果Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭。（那我Client端也可以关闭连接了） 负责域名解析的 DNS 服务DNS(Domain Name System)服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。DNS 协议提供通过 域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。 URI 与 URL URI：统一资源标志符，可以唯一标识一个资源 URL：统一资源定位符，可以提供找到该资源的路径 URL 是 URI 的子集URI 可以是 URL、URN 或者 URL 与 URN 的混合URL 一定是 URI，反之则不然。 URI 格式格式： http://user:pass@www.example.com:80/home/index.html?age=11#mask http：协议方案名 user:pass：登录信息（认证） www.example.com：服务器地址 80：端口号 /hone/index.html：文件路径 age=11：查询字符串 mask：片段标识符协议方案名： http:、https:、ftp:等，在获取资源时要指定协议类型。登录信息(认证)： 指定用户名和密码作为从服务器端获取资源时必要的登录信息，此项是可选的。服务器地址： 使用绝对URI必须指定待访问的服务器地址。服务器端口号： 指定服务器连接的网络端口号，此项是可选的。路径： 指定服务器上的文件路径来定位特定资源。格式为: /home/index.html参数： 为应用程序提供访问资源所需的附加信息。 例如：ftp://127.27.27.27/pub/pic;type=d查询字符串： 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，此项是可选的。片段标识符： 通常可标记出以获取资源中的子资源(文档内的某一个位置)，此项是可选的。 参考链接 TCP的三次握手与四次挥手过程介绍 TCP协议中的三次握手和四次挥手(图解)","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"gulp基础配置","date":"2017-07-01T10:48:55.000Z","path":"2017/07/01/gulp基础配置/","text":"gulp 入门与自用配置最近来了新活，搭建公司官网。用什么技术还真是让我好生纠结了一番。我司的官网主要是展示性网页，所以第一时间排除了 vue，react 等框架，接下来好像只剩 jq 了，但是简单地用 jq 是不是太 low 了？现在是2017年，前端工程化都是炒烂的概念了，咱也不能落后。开始考虑是想弄个简单点的，最先想到的是百度的 fis3，各种配置简单易学，但是思虑再三，还是放弃了。第一点考虑是 fis3 的环境比较封闭，gulp 背靠 npm，各种插件安装使用都很方便；第二点是 gulp 每一个 task 都是自己配置，比较方便我们熟悉整个流程，可控性更强，而且 gulp 可以配合 webpack 等等用在 react 等框架的使用中，至于 webpack 也是以后必学的，也算是个铺垫了；综上，最后我们选择了 gulp。 Gulp 入门 全局安装 gulp 1$ npm install gulp -g 进入项目目录，安装 gulp 作为本项目的依赖之一 12$ cd ~/Code/Demo$ npm install --save-dev gulp 在项目根目录下创建 gulpfile.js 文件 1234var gulp = require('gulp');gulp.task('default', function() &#123; // 任务代码&#125;); 运行 gulp 1$ gulp gulp 常用的四个函数gulp.src输出符合匹配模式的文件，将返回一个 stream，可以被 pipe 到其他插件中。123gulp.src(\"app/css/*.css\") .pipe(mincss()) .pipe(gulp.dest(\"dist/css\")); gulp.sest能够写文件，将会返回 stream，同样可以被 pipe 到其他插件中。 gulp.task定义一个任务。123gulp.task('taskname', function() &#123; // task code&#125;); gulp.watch监听文件变动。123gulp.watch(\"app/scss/**/*.scss\", function() &#123; // do something&#125;); 常用 gulp 插件（不定期更新） browser-sync可以实现本地服务器，实现监听文件变动自动刷新浏览器等功能。详细配置见文档 gulp-sass 编译 scss 文件 123456var sass = require('gulp-sass');gulp.task('sass', function() &#123; return gulp.src(\"app/scss/*.scss\") .pipe(sass()) .pipe(gulp.dest(\"app/css\"));&#125;); gulp-ejs在 html 中使用 ejs 模板引擎 123456var ejs = require('gulp-ejs');gulp.task('ejs', function() &#123; return gulp.src(\"app/templetes/*.html\") .pipe(ejs()) .pipe(gulp.dest(\"app/pages\"));&#125;); gulp-autoprefixer自动添加浏览器前缀 gulp-uglify压缩混淆 js ggulp-mini-css压缩 css gulp-htmlmin压缩 html gulp-imagemin压缩图片 gulp 路径匹配*匹配路径中0个或多个字符，但不会匹配路径分隔符，除非分隔符出现在末尾。12345678// 匹配 style 路径下所有 js 文件./style/*.js// 匹配./style目录下所有文件./style/*.*// 只要层级相同，可以匹配任意目录下的任意js文件 比如./style/a/b.js./style/*/*.js ** 匹配0个或多个层级的目录1234567891011// 匹配style目录及其所有子目录下的所有js文件，如能匹配// ./style/a.js// ./style/lib/res.js// ./style/mudules/b/a.js./style/**/*.js// 匹配style目录下的所有目录和文件，比如能匹配// ./style/a.js// ./style/bb// ./style/images/c.png./style/**/* 参考链接 Gulp中文网 文件路径匹配模式globs","tags":[{"name":"工程化","slug":"工程化","permalink":"http://yoursite.com/tags/工程化/"},{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"iOS与React-Native通信","date":"2017-03-17T01:46:48.000Z","path":"2017/03/17/iOS与React-Native通信/","text":"iOS 与 React Native 通信踩坑小结公司目前的项目主要使用的 React Native，但是 RN 这么久了还只是在 0.x 徘徊，不可避免有很多缺失的功能需要原生开发，然后嵌入到 RN 中，尤其是一些有我天朝特色的，比如支付宝支付，微信 QQ 等的第三方分享。集成支付宝支付的时候，需要在原生里面监听支付结束的动作，然后收到支付宝返回的结果参数，再与自家的后端交互确定最终的支付结果，这里不可避免的涉及到 iOS 监听到支付结束，然后向 RN 发消息。 支付宝带给我的伤害iOS 相关目录大致如下：Alipay 文件夹下即为支付宝相关文件，这里就是比较常用的使 AlipayXss 类遵守 RCTBridgeModule 协议，#import &quot;RCTEventDispatcher.h&quot; 这个是 OC 向 RN 发事件需要用到的。12345678// AlipayXss.h#import &lt;Foundation/Foundation.h&gt;#import &quot;RCTBridgeModule.h&quot;#import &quot;RCTEventDispatcher.h&quot;@interface AlipayXss : NSObject &lt;RCTBridgeModule&gt;@end 123456789101112// AlipayXss.m@synthesize bridge = _bridge;// 括号中的参数用来制定在 js 中访问这个模块的名字，不指定的情况下使用类的名字RCT_EXPORT_MODULE(AlipayXss);// 为声明的模块添加方法，对外暴露的方法RCT_EXPORT_METHOD(pay:(NSString *)orderString fromApp:(NSString *)appScheme) &#123; // 调用支付宝支付 [self doAlipayPay :orderString :appScheme];&#125; 这里RCT_EXPORT_MODULE`RCT_EXPORT_METHOD`这两个宏是将 AlipayXss 模块暴露给 RN，如此 RN 才能调用这里的支付方法。1234[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic) &#123; // 向商家服务端发送 resultDic 在服务端验证是否正确完成支付 [self.bridge.eventDispatcher sendAppEventWithName:@&quot;payResult&quot; body:resultDic];&#125;]; 支付宝文档写明支付完成时会调用这个回掉，然后我就这么写了，在这里发事件将参数传给 RN，在模拟器上表现也很正常，但是后来拿到真机上就傻了，无论如何都 RN 都接收不到这个事件，后来仔细看看文档才知道这个回掉只在用户调起的是网页版支付宝支付结束才会启用，真机上调起的是支付宝 app ，所以不会走这个回调。支付宝 app 支付结束后启用的回掉在 AppDelegate 里，如下1234567891011// AppDelegate.m- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options&#123; if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123; // 支付跳转支付宝钱包进行支付，处理支付结果 [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123; [self.bridge.eventDispatcher sendAppEventWithName:@&quot;payResult&quot; body:resultDic]; &#125;]; &#125; return YES;&#125; 这是我最开始的代码，但是相信我，如果你也这么写了那么你还是只能在 RN 那里干瞪眼，因为你同样接收不到事件，如果你再打断点一步步跟着走你还会发现上面这个方法每一步都完美地执行了，但你就是收不到消息。原因大致是AppDelegate 那里我们用处理之前的 AlipayXss 一样的手法使它遵守了 RCTBridgeModule，这会在模块启动的时候创建一个对象，但是 iOS 应用启动的时候也会创建一个 AppDelegate 的对象，这两个对象是不一样的。StackOverFlow 上有相关问题，链接在这里。但是悲剧的是没有实例呀，对于我这种 OC 都看不太懂的人真是要了老命了，后来陆陆续续看了点 OC 与 RN 通信原理解析又尝试了多种方法弄出来了一个相对简单的方法，如下：1234567891011121314151617181920// AppDelegate.mRCTRootView *rootView;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [self configureAPIKey]; NSURL *jsCodeLocation; jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; fallbackResource:nil]; rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@&quot;xss&quot; initialProperties:nil launchOptions:launchOptions]; rootView.backgroundColor = [[UIColor alloc] initWithRed:1.0f green:1.0f blue:1.0f alpha:1]; // 其他操作&#125; iOS 应用启动时会走 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 方法，在这里实例化了 RCTRootView 对象，并且在这里指定了 js 的引用位置，它作为一个容器包裹着我们的 RN 应用，而在RootView创建之前，RN 先创建了一个 Bridge 对象，它是 OC 与 RN 交互的桥梁，这个东西就与我们碰到的问题息息相关，顺手一提，这里还有一个 setUp 方法，任务是创建 BatchBridge，据说大部分的工作都在这个东西里面。1234567891011// AppDelegate.m- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options&#123; if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123; // 支付跳转支付宝钱包进行支付，处理支付结果 [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123; [rootView.bridge.eventDispatcher sendAppEventWithName:@&quot;payResult&quot; body:resultDic]; &#125;]; &#125; return YES;&#125; 将原本的 self 变为 rootView，这次你可以再 RN 正常地接收事件了。 其他的坑有的时候发消息 RN 无法接收到，一个可能的原因是此时 RN 端的监听事件还没有来得及建立，只要写个延时就 OK。1[self performSelector:@selector(FounctionName) withObject:nil afterDelay:1.0f]; 参考链接 React Native 从入门到原理 一篇较为详细的 iOS react-native 创建 View 过程 源码解析 ReactNative iOS源码解析 React Native 与原生之间的通信(iOS)","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"test","date":"2017-03-16T16:17:24.000Z","path":"2017/03/17/test/","text":"测试微博图床","tags":[]}]